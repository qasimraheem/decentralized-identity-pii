// Generated by LiveScript 1.5.0
/**
 * @package Detox crypto
 * @author  Nazar Mokrynskyi <nazar@mokrynskyi.com>
 * @license 0BSD
 */
(function(){
  var randombytes, TWO_WAY_NOISE_PROTOCOL_NAME, ONE_WAY_NOISE_PROTOCOL_NAME, HANDSHAKE_MESSAGE_LENGTH;
  if (typeof exports === 'object') {
    randombytes = require('crypto').randomBytes;
  } else {
    randombytes = function(size){
      var array;
      array = new Uint8Array(size);
      crypto.getRandomValues(array);
      return array;
    };
  }
  TWO_WAY_NOISE_PROTOCOL_NAME = 'Noise_NK_25519_ChaChaPoly_BLAKE2b';
  ONE_WAY_NOISE_PROTOCOL_NAME = 'Noise_N_25519_ChaChaPoly_BLAKE2b';
  HANDSHAKE_MESSAGE_LENGTH = 48;
  /**
   * Increment nonce from `nonce` argument in place
   *
   * @param {!Uint8Array} nonce
   */
  function increment_nonce(nonce){
    var i$, index;
    for (i$ = nonce.length - 1; i$ >= 0; --i$) {
      index = i$;
      ++nonce[index];
      if (nonce[index] !== 0) {
        break;
      }
    }
  }
  function Crypto(supercop, ed25519ToX25519, aez, noiseC, blake2){
    /**
     * @param {Uint8Array} seed Random seed will be generated if `null`
     *
     * @return {!Object}
     */
    function create_keypair(seed){
      var keys;
      seed == null && (seed = null);
      if (!seed) {
        seed = supercop['createSeed']();
      }
      keys = supercop['createKeyPair'](seed);
      return {
        'seed': seed,
        'ed25519': {
          'public': keys['publicKey'],
          'private': keys['secretKey']
        },
        'x25519': {
          'public': ed25519ToX25519['convert_public_key'](keys['publicKey']),
          'private': ed25519ToX25519['convert_private_key'](seed)
        }
      };
    }
    /**
     * @param {!Uint8Array} public_key Ed25519 public key
     *
     * @return {Uint8Array} X25519 public key (or `null` if `public_key` was invalid)
     */
    function convert_public_key(public_key){
      return ed25519ToX25519['convert_public_key'](public_key);
    }
    /**
     * @param {!Uint8Array} data
     * @param {!Uint8Array} public_key Ed25519 public key
     * @param {!Uint8Array} private_key Ed25519 private key
     *
     * @return {!Uint8Array}
     */
    function sign(data, public_key, private_key){
      return supercop['sign'](data, public_key, private_key);
    }
    /**
     * @param {!Uint8Array} signature
     * @param {!Uint8Array} data
     * @param {!Uint8Array} public_key Ed25519 public key
     *
     * @return {boolean}
     */
    function verify(signature, data, public_key){
      return supercop['verify'](signature, data, public_key);
    }
    /**
     * @constructor
     *
     * @param {Uint8Array} key Empty when initialized by initiator and specified on responder side
     *
     * @return {!Rewrapper}
     */
    function Rewrapper(key){
      key == null && (key = null);
      if (!(this instanceof Rewrapper)) {
        return new Rewrapper(key);
      }
      if (key === null) {
        key = randombytes(48);
      }
      this._key = key;
      this._nonce = new Uint8Array(12);
    }
    Rewrapper.prototype = {
      /**
       * @return {!Uint8Array}
       */
      'get_key': function(){
        return this._key;
      }
      /**
       * @param {!Uint8Array} plaintext
       *
       * @return {!Uint8Array} Ciphertext
       */,
      'wrap': function(plaintext){
        increment_nonce(this._nonce);
        return aez['encrypt'](plaintext, new Uint8Array(0), this._nonce, this._key, 0);
      }
      /**
       * @param {!Uint8Array} ciphertext
       *
       * @return {!Uint8Array} Plaintext
       */,
      'unwrap': function(ciphertext){
        increment_nonce(this._nonce);
        return aez['decrypt'](ciphertext, new Uint8Array(0), this._nonce, this._key, 0);
      }
    };
    Object.defineProperty(Rewrapper.prototype, 'constructor', {
      value: Rewrapper
    });
    /**
     * @constructor
     *
     * @param {boolean} initiator
     * @param {!Uint8Array} key Responder's public X25519 key if `initiator` is `true` or responder's private X25519 key if `initiator` is `false`
     *
     * @return {!Encryptor}
     *
     * @throws {Error}
     */
    function Encryptor(initiator, key){
      if (!(this instanceof Encryptor)) {
        return new Encryptor(initiator, key);
      }
      if (initiator) {
        this._handshake_state = noiseC['HandshakeState'](TWO_WAY_NOISE_PROTOCOL_NAME, noiseC['constants']['NOISE_ROLE_INITIATOR']);
        this._handshake_state['Initialize'](null, null, key);
      } else {
        this._handshake_state = noiseC['HandshakeState'](TWO_WAY_NOISE_PROTOCOL_NAME, noiseC['constants']['NOISE_ROLE_RESPONDER']);
        this._handshake_state['Initialize'](null, key);
      }
    }
    Encryptor.prototype = {
      /**
       * @return {boolean}
       */
      'ready': function(){
        return !this._handshake_state;
      }
      /**
       * @return {Uint8Array} Handshake message that should be sent to the other side or `null` otherwise
       *
       * @throws {Error}
       */,
      'get_handshake_message': function(){
        var message;
        message = null;
        if (this._handshake_state) {
          if (this._handshake_state['GetAction']() === noiseC['constants']['NOISE_ACTION_WRITE_MESSAGE']) {
            message = this._handshake_state['WriteMessage']();
          }
          this._handshake_common();
        }
        return message;
      }
      /**
       * @param {!Uint8Array} message Handshake message received from the other side
       *
       * @throws {Error}
       */,
      'put_handshake_message': function(message){
        if (this._handshake_state) {
          if (this._handshake_state['GetAction']() === noiseC['constants']['NOISE_ACTION_READ_MESSAGE']) {
            this._handshake_state['ReadMessage'](message);
          }
          this._handshake_common();
        }
      },
      _handshake_common: function(){
        var action, ref$, ad, plaintext;
        action = this._handshake_state['GetAction']();
        if (action === noiseC['constants']['NOISE_ACTION_SPLIT']) {
          ref$ = this._handshake_state['Split'](), this._send_cipher_state = ref$[0], this._receive_cipher_state = ref$[1];
          ad = new Uint8Array(0);
          plaintext = new Uint8Array(48 - 16);
          this._rewrapper_send_key = this._send_cipher_state['EncryptWithAd'](ad, plaintext);
          this._rewrapper_receive_key = this._receive_cipher_state['EncryptWithAd'](ad, plaintext);
          delete this._handshake_state;
        } else if (action === noiseC['constants']['NOISE_ACTION_FAILED']) {
          delete this._handshake_state;
          throw new Error('Noise handshake failed');
        }
      }
      /**
       * @return {!Array<Uint8Array>} Array `[send_key, receive_key]`, both keys 48 bytes
       */,
      'get_rewrapper_keys': function(){
        return [this._rewrapper_send_key, this._rewrapper_receive_key];
      }
      /**
       * @param {!Uint8Array} plaintext
       *
       * @return {!Uint8Array}
       *
       * @throws {Error}
       */,
      'encrypt': function(plaintext){
        return this._send_cipher_state['EncryptWithAd'](new Uint8Array(0), plaintext);
      }
      /**
       * @param {!Uint8Array} ciphertext
       *
       * @return {!Uint8Array}
       *
       * @throws {Error}
       */,
      'decrypt': function(ciphertext){
        return this._receive_cipher_state['DecryptWithAd'](new Uint8Array(0), ciphertext);
      },
      'destroy': function(){
        if (this._handshake_state) {
          this._handshake_state['free']();
        }
        if (this._send_cipher_state) {
          this._send_cipher_state['free']();
        }
        if (this._receive_cipher_state) {
          this._receive_cipher_state['free']();
        }
      }
    };
    Object.defineProperty(Encryptor.prototype, 'constructor', {
      value: Encryptor
    });
    /**
     * @param {!Uint8Array} public_key	Responder's public X25519 key
     * @param {!Uint8Array} plaintext
     *
     * @return {!Uint8Array}
     *
     * @throws {Error}
     */
    function one_way_encrypt(public_key, plaintext){
      var handshake_state, handshake_message, ref$, send_cipher_state, receive_cipher_state, ciphertext, x$;
      handshake_state = noiseC['HandshakeState'](ONE_WAY_NOISE_PROTOCOL_NAME, noiseC['constants']['NOISE_ROLE_INITIATOR']);
      handshake_state['Initialize'](null, null, public_key);
      handshake_message = handshake_state['WriteMessage']();
      ref$ = handshake_state['Split'](), send_cipher_state = ref$[0], receive_cipher_state = ref$[1];
      ciphertext = send_cipher_state['EncryptWithAd'](new Uint8Array(0), plaintext);
      send_cipher_state['free']();
      receive_cipher_state['free']();
      x$ = new Uint8Array(HANDSHAKE_MESSAGE_LENGTH + ciphertext.length);
      x$.set(handshake_message);
      x$.set(ciphertext, HANDSHAKE_MESSAGE_LENGTH);
      return x$;
    }
    /**
     * @param {!Uint8Array} private_key	Responder's private X25519 key
     * @param {!Uint8Array} message
     *
     * @return {!Uint8Array}
     *
     * @throws {Error}
     */
    function one_way_decrypt(private_key, message){
      var handshake_message, ciphertext, handshake_state, ref$, send_cipher_state, receive_cipher_state, plaintext;
      handshake_message = message.subarray(0, HANDSHAKE_MESSAGE_LENGTH);
      ciphertext = message.subarray(HANDSHAKE_MESSAGE_LENGTH);
      handshake_state = noiseC['HandshakeState'](ONE_WAY_NOISE_PROTOCOL_NAME, noiseC['constants']['NOISE_ROLE_RESPONDER']);
      handshake_state['Initialize'](null, private_key);
      handshake_state['ReadMessage'](handshake_message);
      ref$ = handshake_state['Split'](), send_cipher_state = ref$[0], receive_cipher_state = ref$[1];
      plaintext = receive_cipher_state['DecryptWithAd'](new Uint8Array(0), ciphertext);
      send_cipher_state['free']();
      receive_cipher_state['free']();
      return plaintext;
    }
    /**
     * @param {!Uint8Array} data
     *
     * @return {!Uint8Array}
     */
    function blake2b_256(data){
      return blake2['Blake2b'](32)['update'](data)['final']();
    }
    return {
      'ready': function(callback){
        aez['ready'](function(){
          blake2['ready'](function(){
            ed25519ToX25519['ready'](function(){
              noiseC['ready'](function(){
                supercop['ready'](function(){
                  callback();
                });
              });
            });
          });
        });
      },
      'create_keypair': create_keypair,
      'convert_public_key': convert_public_key,
      'sign': sign,
      'verify': verify,
      'Rewrapper': Rewrapper,
      'Encryptor': Encryptor,
      'one_way_encrypt': one_way_encrypt,
      'one_way_decrypt': one_way_decrypt,
      'blake2b_256': blake2b_256
    };
  }
  if (typeof define === 'function' && define['amd']) {
    define(['supercop.wasm', 'ed25519-to-x25519.wasm', 'aez.wasm', 'noise-c.wasm', 'blake2.wasm'], Crypto);
  } else if (typeof exports === 'object') {
    module.exports = Crypto(require('supercop.wasm'), require('ed25519-to-x25519.wasm'), require('aez.wasm'), require('noise-c.wasm'), require('blake2.wasm'));
  } else {
    this['detox_crypto'] = Crypto(this['supercop_wasm'], this['ed25519_to_x25519_wasm'], this['aez_wasm'], this['noise_c_wasm'], this['blake2_wasm']);
  }
}).call(this);
